package eudore

import (
	"reflect"
	"sort"
	"strings"
)

// Controller defines the controller interface and implements
// custom [Router] registration.
type Controller interface {
	Inject(ctl Controller, router Router) error
}

type controllerGroup interface {
	ControllerGroup(pkg string, name string) string
}

// controllerRoute defines the interface for get route and method mapping.
type controllerRoute interface {
	ControllerRoute() map[string]string
}

// controllerParam defines the interface for get route [Params],
// using the route [Params] returned by pkg, controllername, and methodname.
type controllerParam interface {
	ControllerParam(pkg string, name string, method string) string
}

// The ControllerAutoRoute implements the routing mapping controller
// to register the corresponding router method according to the method.
//
// If the controller is composed of other objects,
// the method name suffixed with the 'Controller' object will be
// used to generate the route.
type ControllerAutoRoute struct{}

// ControllerAutoType additionally registers the [HandlerExtender] corresponding
// to type T.
//
// refer [ControllerAutoRoute].
type ControllerAutoType[T any] struct{}

type controllerError struct {
	Controller
	Error error
}

// NewControllerError function returns a [controllerError],
// and the corresponding error is returned when the [Controller] Inject.
func NewControllerError(ctl Controller, err error) Controller {
	return &controllerError{
		Controller: ctl,
		Error:      err,
	}
}

// The Inject method returns a controller error when injecting routing rules.
func (ctl controllerError) Inject(Controller, Router) error {
	return ctl.Error
}

func (ctl controllerError) Unwrap() Controller {
	return ctl.Controller
}

// Inject method implements the method of injecting the [Controller]
// into the [Router], and the [ControllerAutoRoute] controller calls the
// [ControllerInjectAutoRoute] method to inject.
//
// The first word of the controller method must be in the title format,
// defined in DefaultRouterAllMethod;
//
// ByName is converted to variable matching /:name;
// the last word is By and is converted to /*;
// other words are converted to constant matching.
//
//	ANY              => ANY /*
//	GetByID          => GET /:id
//	PostGroupsByIDBy => POST /groups/:id/*
func (ControllerAutoRoute) Inject(ctl Controller, router Router) error {
	return ControllerInjectAutoRoute(ctl, router)
}

// The ControllerGroup method returns the [Router.Group] registered by
// the [Controller]. If it returns null string, it is ignored.
//
// refer [getContrllerGroup].
func (ControllerAutoRoute) ControllerGroup(pkg, name string) string {
	return controllerDefaultGroup(pkg, name)
}

// The ControllerRoute method can specify the route generated by the method,
// or append route [Params].
//
// The map key is the controller method, the value is the route,
// and the method is ignored when the value is '-',
// value format: '{method} path {[Params]}'.
//
//	/index
//	/index action=GetIndex
//	GET /index
//	GET /index action=GetIndex
//	 name=GetIndex
func (ControllerAutoRoute) ControllerRoute() map[string]string {
	return nil
}

// The ControllerParam method returns the [Params] used when each method
// is converted into a route.
//
// The default format is: [DefaultControllerParam].
func (ControllerAutoRoute) ControllerParam(pkg, name, method string) string {
	return controllerDefaultGroupParam(pkg, name, method)
}

func controllerDefaultGroup(_, name string) string {
	name = strings.TrimSuffix(name, "Controller")
	buf := make([]rune, 0, len(name)*2)
	for _, b := range name {
		if 64 < b && b < 91 {
			buf = append(buf, '/', b+0x20)
		} else {
			buf = append(buf, b)
		}
	}
	return string(buf)
}

// The controllerDefaultGroupParam function defines the
// default controller [Params],
// which can be overridden by implementing [controllerParam].
func controllerDefaultGroupParam(pkg, name, method string) string {
	param := DefaultControllerParam
	param = strings.ReplaceAll(param, "{{Package}}", pkg)
	param = strings.ReplaceAll(param, "{{Name}}", name)
	param = strings.ReplaceAll(param, "{{Method}}", method)
	return param
}

// Inject method calls the [ControllerInjectAutoRoute] method to inject,
// And register the [HandlerExtender] of typeParam T.
//
// refer [ControllerInjectAutoRoute].
func (ControllerAutoType[T]) Inject(ctl Controller, router Router) error {
	router = router.Group(" " + ParamLoggerKind + "=~extend")
	_ = router.AddHandlerExtend(
		NewHandlerFuncContextType[*T],
		NewHandlerFuncContextTypeAny[*T],
		NewHandlerFuncContextTypeError[*T],
		NewHandlerFuncContextTypeAnyError[*T],
		NewHandlerFuncContextType[[]T],
		NewHandlerFuncContextTypeAny[[]T],
		NewHandlerFuncContextTypeError[[]T],
		NewHandlerFuncContextTypeAnyError[[]T],
	)
	return ControllerInjectAutoRoute(ctl, router)
}

// ControllerInjectAutoRoute implements controller method injection routes.
//
// refer: [ControllerAutoRoute] [ControllerAutoRoute.Inject]
// [ControllerAutoRoute.ControllerGroup]
// [ControllerAutoRoute.ControllerRoute]
// [ControllerAutoRoute.ControllerParam].
func ControllerInjectAutoRoute(ctl Controller, router Router) error {
	iType := reflect.TypeOf(ctl)
	v := reflect.ValueOf(ctl)

	// Add the controller group.
	cname := getControllerName(v)
	cpkg := reflect.Indirect(v).Type().PkgPath()
	router = getContrllerGroup(router, ctl, cpkg, cname)

	// Get route parameter function
	pfn := controllerDefaultGroupParam
	p, ok := ctl.(controllerParam)
	if ok {
		pfn = p.ControllerParam
	}

	// Router registration controller method
	names, paths := getSortRoutes(getControllerRoutes(ctl))
	for i, name := range names {
		m, ok := iType.MethodByName(name)
		if !ok || paths[i] == "-" {
			continue
		}

		method := getMethodByName(name)
		if method == "" {
			method = MethodAny
		}
		path := paths[i] + " " + pfn(cpkg, cname, name)
		err := router.AddHandler(method, path, v.Method(m.Index).Interface())
		if err != nil {
			return err
		}
	}
	return nil
}

func getControllerName(v reflect.Value) string {
	name := reflect.Indirect(v).Type().Name()
	// typeParam name
	pos := strings.IndexByte(name, '[')
	if pos != -1 {
		name = name[:pos]
	}
	return name
}

func getContrllerGroup(router Router, ctl Controller, pkg, name string) Router {
	var group string
	g, ok := ctl.(controllerGroup)
	switch {
	case router.Params().Get(ParamControllerGroup) != "":
		group = router.Params().Get(ParamControllerGroup)
		router.Params().Del(ParamControllerGroup)
	case ok:
		group = g.ControllerGroup(pkg, name)
	default:
		group = controllerDefaultGroup(pkg, name)
	}

	if group == "" {
		return router
	}
	if group[0] != '/' {
		return router.Group("/" + group)
	}
	return router.Group(group)
}

func getSortRoutes(data map[string]string) ([]string, []string) {
	keys := make([]string, 0, len(data))
	vals := make([]string, len(data))
	for key := range data {
		keys = append(keys, key)
	}
	sort.Slice(keys, func(i, j int) bool {
		ri, rj := data[keys[i]], data[keys[j]]
		if ri == rj {
			return getSortMethodIndex(keys[i]) < getSortMethodIndex(keys[j])
		}
		return ri < rj
	})

	for i, key := range keys {
		vals[i] = data[key]
	}
	return keys, vals
}

func getSortMethodIndex(method string) int {
	method = getMethodByName(method)
	if method == MethodAny {
		return 0
	}
	return sliceIndex(DefaultRouterAllMethod, method) + 1
}

// The getControllerRoutes function gets a mapping of all names and routes from
// a [Controller] type.
func getControllerRoutes(controller Controller) map[string]string {
	routes := getContrllerAllowMethos(controller)
	for name := range routes {
		if getMethodByName(name) != "" {
			routes[name] = getRouteByName(name)
		} else {
			delete(routes, name)
		}
	}

	// If the controller implements the [ControllerRoute] interface,
	// load additional routes.
	controllerRoute, isRoute := controller.(controllerRoute)
	if isRoute {
		for name, path := range controllerRoute.ControllerRoute() {
			if len(path) > 0 && path[0] == ' ' {
				// The path by ControllerRoute starts with a space,
				// indicating a route [Params].
				routes[name] += path
			} else {
				routes[name] = path
			}
		}
	}
	return routes
}

func getContrllerAllowMethos(ctl Controller) map[string]string {
	t := reflect.TypeOf(ctl)
	names := make(map[string]string)
	for _, name := range getContrllerAllMethos(t) {
		names[name] = ""
	}

	for t.Kind() == reflect.Ptr || t.Kind() == reflect.Interface {
		t = t.Elem()
	}
	if t.Kind() == reflect.Struct {
		// Remove non-embedded controller methods
		for i := 0; i < t.NumField(); i++ {
			if !controllerField(t.Field(i)) {
				for _, name := range getContrllerAllMethos(t.Field(i).Type) {
					delete(names, name)
				}
			}
		}
		for i := 0; i < t.NumField(); i++ {
			if controllerField(t.Field(i)) {
				for _, name := range getContrllerAllMethos(t.Field(i).Type) {
					names[name] = ""
				}
			}
		}
	}
	return names
}

// The getContrllerAllMethos function get the names of all methods whose types
// include pointer types.
func getContrllerAllMethos(t reflect.Type) []string {
	names := make([]string, t.NumMethod())
	for i := 0; i < t.NumMethod(); i++ {
		names[i] = t.Method(i).Name
	}
	return names
}

func controllerField(field reflect.StructField) bool {
	return field.Anonymous && strings.HasSuffix(field.Name, "Controller")
}

// The getRouteByName function generates a route using the function name.
func getRouteByName(name string) string {
	names := splitTitleName(name)
	if getMethodByName(names[0]) != "" {
		names = names[1:]
	}
	name = ""
	for i := 0; i < len(names); i++ {
		if names[i] == "By" {
			i++
			if i == len(names) {
				name += "/" + "*"
			} else {
				name = name + "/:" + names[i]
			}
		} else {
			name = name + "/" + names[i]
		}
	}
	if name == "" {
		name = "/" + "*"
	}
	return strings.ToLower(name)
}

func getMethodByName(name string) string {
	name = strings.ToUpper(getFirstUp(name))
	if name == "ANY" {
		return MethodAny
	}
	for _, method := range DefaultRouterAllMethod {
		if method == name {
			return name
		}
	}
	return ""
}

func getFirstUp(name string) string {
	for i, c := range name {
		if 0x40 < c && c < 0x5B && i != 0 {
			return name[:i]
		}
	}
	return name
}

// The splitTitleName method splits the path based on the capitalization of
// the first character.
func splitTitleName(str string) []string {
	var body []byte
	for i := range str {
		switch {
		case i != 0 && byteIn(str[i], 0x40) && byteIn(str[i-1], 0x60):
			body = append(body, ' ')
			body = append(body, str[i])
		case i != 0 && i != len(str)-1 && byteIn(str[i], 0x40) &&
			byteIn(str[i-1], 0x40) && byteIn(str[i+1], 0x60):
			body = append(body, ' ')
			body = append(body, str[i])
		case byteIn(str[i], 0x40) && i != 0:
			body = append(body, str[i]+0x20)
		default:
			body = append(body, str[i])
		}
	}
	return strings.Split(string(body), " ")
}

func byteIn(b byte, r byte) bool {
	return r < b && b < r+0x1B
}
